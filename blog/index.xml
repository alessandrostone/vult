<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on Vult by modlfo</title>
    <link>http://modlfo.github.io/vult/blog/</link>
    <description>Recent content in Blogs on Vult by modlfo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 18 Oct 2016 22:56:13 +0300</lastBuildDate>
    <atom:link href="http://modlfo.github.io/vult/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Generating up-to-date binaries with CI</title>
      <link>http://modlfo.github.io/vult/blog/ci-integration/</link>
      <pubDate>Tue, 18 Oct 2016 22:56:13 +0300</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/ci-integration/</guid>
      <description>&lt;p&gt;I have been using Travis CI for running tests and checking that Vult build correctly. Travis CI can build Vult in OSX and Linux. However, due to the status of OCaml it was difficult to setup something similar in Windows with AppVeyor. Thankfully the OCaml community has published a set of script to configure different CI services:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ocaml/ocaml-ci-scripts&#34;&gt;https://github.com/ocaml/ocaml-ci-scripts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using those scripts I could get the AppVeyor continuous integration working. Here you can take a look at the status of both services:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ci.appveyor.com/project/modlfo/vult&#34;&gt;https://ci.appveyor.com/project/modlfo/vult&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://travis-ci.org/modlfo/vult&#34;&gt;https://travis-ci.org/modlfo/vult&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once I got the things working. I started a long run of commits to get the CI services to deploy automatically every tag as a Github release. More than 30 commits later I got it working. You can see the releases here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/modlfo/vult/releases&#34;&gt;https://github.com/modlfo/vult/releases&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can find there binaries for Windows, OSX and Linux.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Now Vult can be installed from npm</title>
      <link>http://modlfo.github.io/vult/blog/vult-in-npm/</link>
      <pubDate>Tue, 04 Oct 2016 19:22:30 +0300</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/vult-in-npm/</guid>
      <description>&lt;p&gt;In the last months I have been making many improvements to the Vult compiler. These improvements cannot be easily tried by the users due to the fact that for me creating binaries for all the platforms is very time consuming. Therefore, in order for the users to try the latests changes they need to compile Vult from the source code. Even though the process is well documented in the repository, this can be time consuming and difficult for people unfamiliar with the OCaml tools.&lt;/p&gt;

&lt;p&gt;I have been using &lt;code&gt;js_of_ocaml&lt;/code&gt; for quite some time to convert parts of the Vult compiler to JavaScript that runs in the live demo page &lt;a href=&#34;http://modlfo.github.io/vult/demo/&#34;&gt;http://modlfo.github.io/vult/demo/&lt;/a&gt; however the code there does not perform any I/O to disk since it&amp;rsquo;s intended to run in the web browser.&lt;/p&gt;

&lt;p&gt;I tried to convert the whole application to JavaScript to see if it could run (as it is) with the latest improvements of &lt;code&gt;js_of_ocaml&lt;/code&gt;. That way I can distribute a JavaScript version that can be run with node.js. Node.js has many advantages, for example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;runs in most platforms&lt;/li&gt;
&lt;li&gt;easy to install&lt;/li&gt;
&lt;li&gt;it has a good package manager&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fortunately, the only thing that did not work was the file I/O (which seems reasonable). In order to make it work I made a small hack that allowed me to switch the functions that read and write files. That way I can declare bindings for the node.js functions and replace them. Here&amp;rsquo;s the code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;(** Declares a &#39;buffer&#39; object *)
class type buffer = object
   method toString : js_string t meth
end

(** Declares a &#39;fs&#39; object *)
class type fs = object
   method readFileSync : js_string t -&amp;gt; buffer t meth
   method writeFileSync : js_string t -&amp;gt; js_string t -&amp;gt; unit t meth
end

(* var fs = require(&#39;fs&#39;) *)
let fs : fs t =
   Unsafe.fun_call (Unsafe.js_expr &amp;quot;require&amp;quot;)
      [|Unsafe.inject (string &amp;quot;fs&amp;quot;)|]

let read_fn (path:string) : string option =
   let buffer   = fs##readFileSync (string path) in
   let contents = to_string (buffer##toString ()) in
   Some(contents)

let write_fn (path:string) (text:string) : bool =
   let _ = fs##writeFileSync ((string path),(string text)) in
   true
;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then I replace the functions as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;FileIO.setRead read_fn ;;
FileIO.setWrite write_fn ;;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With those changes it&amp;rsquo;s possible to compile the bytecode and convert it to JavaScript. Now it&amp;rsquo;s possible to run the Vult compiler as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ node vultjs.js arguments
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thanks to the npm it is even easier to install Vult an run it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install vult -g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command will give you an &amp;ldquo;executable&amp;rdquo; that can be called simply as &lt;code&gt;vultc&lt;/code&gt;, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vultc -ccode infile.vult -o outfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the repository for the package &lt;a href=&#34;https://github.com/modlfo/vultjs&#34;&gt;https://github.com/modlfo/vultjs&lt;/a&gt; and this is the main page of the npm package &lt;a href=&#34;https://www.npmjs.com/package/vult&#34;&gt;https://www.npmjs.com/package/vult&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I will update the source code every time I think the changes in trunk are useful.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LuaJIT as backend for Vult</title>
      <link>http://modlfo.github.io/vult/blog/lua/</link>
      <pubDate>Thu, 08 Sep 2016 22:43:03 +0300</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/lua/</guid>
      <description>&lt;p&gt;I have been keeping an eye on LuaJIT (&lt;a href=&#34;http://luajit.org&#34;&gt;http://luajit.org&lt;/a&gt;) for some time. It&amp;rsquo;s a very interesting project and I have read very good things about it. Some time ago I made a small benchmark comparing an optimized algorithm written in C++11 against a lazy coded version in OCaml and LuaJIT. In case you are curious here are the results:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Language&lt;/th&gt;
&lt;th&gt;Execution Time&lt;/th&gt;
&lt;th&gt;Lines of Code&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;td&gt;0.355 s&lt;/td&gt;
&lt;td&gt;180&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;OCaml&lt;/td&gt;
&lt;td&gt;0.54 s&lt;/td&gt;
&lt;td&gt;63&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LuaJIT&lt;/td&gt;
&lt;td&gt;0.78 s&lt;/td&gt;
&lt;td&gt;85&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Here&amp;rsquo;s a chart that plots the lines of code against the execution time.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;../images/benchmark1.svg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;I have to remark again: &lt;em&gt;The OCaml and Lua code were not written with optimization in mind&lt;/em&gt;. My intention was to see how fast they program could go without putting too much effort coding.&lt;/p&gt;

&lt;p&gt;One can see that the C++ code is much larger. On the other hand, the OCaml code is very compact. The main reason was that in OCaml I used algebraic data types which neither Lua or C++ have (&lt;a href=&#34;https://en.wikipedia.org/wiki/Algebraic_data_type&#34;&gt;https://en.wikipedia.org/wiki/Algebraic_data_type&lt;/a&gt;). Therefore, all the complex data types needed to be implemented with classes or tables in the case of Lua.&lt;/p&gt;

&lt;p&gt;Recently I implemented a prototype of code generation Vult -&amp;gt; Lua in order to check if LuaJIT could be used to create a better live coding environment. I took the JavaScript generator and with a few modifications I got Lua support.&lt;/p&gt;

&lt;p&gt;To generate Lua code you need to call Vult as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./vultc.native -luacode code.vult -o code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to check the performance I took one of the examples I have in Vult and made a test rendering 1000 s of audio. Here are the results:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Language&lt;/th&gt;
&lt;th&gt;Execution Time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;td&gt;2.77 s&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LuaJIT&lt;/td&gt;
&lt;td&gt;3.55 s&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Here&amp;rsquo;s the graphic view:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;../images/benchmark2.svg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;The results are quite promising. The code was pure Lua with exception of the arrays which are implemented using the LuaJIT FFI as &lt;code&gt;double[]&lt;/code&gt;. One important thing to notice is that the LuaJIT performs all operations in &lt;code&gt;double&lt;/code&gt; precision, while the C/C++ uses &lt;code&gt;float&lt;/code&gt;. I&amp;rsquo;m not sure if this has a big impact or not in modern processors.&lt;/p&gt;

&lt;p&gt;As follow up in this topic, I&amp;rsquo;m planning to do more testing to see if I can generate code that is faster in LuaJIT taking advantage of the FFI features. I&amp;rsquo;m gonna try as well to find a nice way of integrating LuaJIT + Vult into a VST or a PD external.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generating Pure Data and Teensy Audio templates</title>
      <link>http://modlfo.github.io/vult/blog/pd-teensy/</link>
      <pubDate>Wed, 13 Jul 2016 20:10:57 +0200</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/pd-teensy/</guid>
      <description>&lt;p&gt;As part of the Vult project I have developed a new standalone library: Pla (&lt;a href=&#34;https://modlfo.github.io/pla/&#34;&gt;https://modlfo.github.io/pla/&lt;/a&gt;). Pla is a templating library that is used in Vult to generate code in a simpler way. Thanks to this library I have developed two templates to simplify using Vult:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/modlfo/pd-vult-example&#34;&gt;Pure Data externals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/modlfo/pd-vult-example&#34;&gt;Teensy Audio Library objects&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The template for Pure Data is more stable. It supports both, floating-point and fixed-point arithmetics. In addition, the number of inputs and outputs of the &amp;lsquo;external&amp;rsquo; matches the inputs and outputs of the &lt;code&gt;process&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;You can find an example of using it in this repository: &lt;a href=&#34;https://github.com/modlfo/pd-vult-example&#34;&gt;https://github.com/modlfo/pd-vult-example&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Exporting of objects for the Teensy Audio Library is only available in fixed-point and (currently) only supports synthesis objects (I have plans to make it as flexible as the PD template).&lt;/p&gt;

&lt;p&gt;Here you can find an example: &lt;a href=&#34;https://github.com/modlfo/teensy-vult-example&#34;&gt;https://github.com/modlfo/teensy-vult-example&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>New site for Vult</title>
      <link>http://modlfo.github.io/vult/blog/new-site/</link>
      <pubDate>Tue, 12 Jul 2016 20:21:43 +0200</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/new-site/</guid>
      <description>&lt;p&gt;I have been working on giving a refresh of the Vult site. The result is what you see now. After trying a few alternatives I settle to use Hugo (&lt;a href=&#34;https://gohugo.io&#34;&gt;https://gohugo.io&lt;/a&gt;). The reason I used Hugo was because I could make it do exactly what I wanted with the help of the documentation.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m very proud that I did the theme of the site from the ground up (that&amp;rsquo;s why is so minimalistic). I also added comments section using Google+, and I hope it works as expected.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>