<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog-rsses on Vult by modlfo</title>
    <link>http://modlfo.github.io/vult/blog/index.xml</link>
    <description>Recent content in Blog-rsses on Vult by modlfo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 01 Dec 2016 15:49:04 -0600</lastBuildDate>
    <atom:link href="http://modlfo.github.io/vult/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Automatic loading of Vult files</title>
      <link>http://modlfo.github.io/vult/blog/automatic-loading/</link>
      <pubDate>Thu, 01 Dec 2016 15:49:04 -0600</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/automatic-loading/</guid>
      <description>

&lt;p&gt;Recently I implemented simpler way to call the Vult compiler with multiple files. Previously Vult required that you passed every file in a correct order. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vultc -ccode file1.vult file2.vult
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case the &lt;code&gt;file2.vult&lt;/code&gt; used functions from the &lt;code&gt;file1.vult&lt;/code&gt;. As the number of files increased it also increased the complexity of the call to the compiler.&lt;/p&gt;

&lt;p&gt;Compiling code now is easier. With the latest Vult compiler you just have to pass as argument your top file. In the previous example the call would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vultc -ccode file2.vult
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Based on the dependencies Vult will look for the corresponding files matching the convention that every module name  (for example &lt;code&gt;Util&lt;/code&gt;) has a corresponding file called &lt;code&gt;util.vult&lt;/code&gt;. Vult will look for the matching files in all the directories of the input files. For example the call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vultc /home/leonardo/dir1/file1.vult /home/leonardo/dir2/file2.vult
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will look for dependencies in the directories:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/home/leonardo/dir1/
/home/leonardo/dir2/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One important thing to notice is that the file order does not matter anymore.&lt;/p&gt;

&lt;p&gt;Vult will also look for files in the current working directory.&lt;/p&gt;

&lt;p&gt;If you want to add more directories to the search you can use the flag &lt;code&gt;-i&lt;/code&gt;. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vultc file1.vult -i /home/leonardo/dir2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;implementation&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;Solving this problem is in fact very easy. When a file is loaded first it&amp;rsquo;s necessary to get all its dependencies. Once the dependencies are detected, we need to look for the matching files in the implicit and explicit search locations. The same process is repeated until every file has been loaded. At this point, we have a list of all the necessary files. Now we have to load every file in the correct order because Vult does not support forward declarations of functions. To determine the order we can use topological sorting of the dependency graph.&lt;/p&gt;

&lt;p&gt;The actual implementation uses the &lt;a href=&#34;http://www.geeksforgeeks.org/strongly-connected-components/&#34;&gt;Strongly Connected Components&lt;/a&gt; algorithm. The reason of using this instead of simple &lt;a href=&#34;https://en.wikipedia.org/wiki/Topological_sorting&#34;&gt;Topological sorting&lt;/a&gt; is that the Strongly Connected Components algorithm will tell us if there are any cyclical dependencies, which is an error in Vult.&lt;/p&gt;

&lt;p&gt;You can find the complete implementation in OCaml in the file &lt;a href=&#34;https://github.com/modlfo/vult/blob/master/src/util/components.ml&#34;&gt;src/util/components.ml&lt;/a&gt;. The actual implementation of the Kosaraju&amp;rsquo;s algorithm is very compact, less than 40 lines of code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>New repository with more PureData examples</title>
      <link>http://modlfo.github.io/vult/blog/more-examples/</link>
      <pubDate>Tue, 01 Nov 2016 22:14:59 +0200</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/more-examples/</guid>
      <description>&lt;p&gt;A new repository with more Vult examples is available:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/modlfo/vult-examples&#34;&gt;https://github.com/modlfo/vult-examples&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This repository contains a set of standalone Vult files that can be easily compiled as PureData objects.&lt;/p&gt;

&lt;p&gt;The main idea behind this objects is to create collection of &amp;ldquo;modules&amp;rdquo; that try to follow the Eurorack voltage convention: the inputs are controlled by voltages. The oscillators follow the convention of 1 volt per octave. Parameters use a range of 0-5 volts.&lt;/p&gt;

&lt;p&gt;The repository also contains a few objects called &amp;ldquo;units&amp;rdquo; that are more complex modules composed with smaller objects, for example: a drum and mono synthesizer.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generating up-to-date binaries with CI</title>
      <link>http://modlfo.github.io/vult/blog/ci-integration/</link>
      <pubDate>Tue, 18 Oct 2016 22:56:13 +0300</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/ci-integration/</guid>
      <description>&lt;p&gt;I have been using Travis CI for running tests and checking that Vult build correctly. Travis CI can build Vult in OSX and Linux. However, due to the status of OCaml it was difficult to setup something similar in Windows with AppVeyor. Thankfully the OCaml community has published a set of script to configure different CI services:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ocaml/ocaml-ci-scripts&#34;&gt;https://github.com/ocaml/ocaml-ci-scripts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using those scripts I could get the AppVeyor continuous integration working. Here you can take a look at the status of both services:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ci.appveyor.com/project/modlfo/vult&#34;&gt;https://ci.appveyor.com/project/modlfo/vult&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://travis-ci.org/modlfo/vult&#34;&gt;https://travis-ci.org/modlfo/vult&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once I got the things working. I started a long run of commits to get the CI services to deploy automatically every tag as a Github release. More than 30 commits later I got it working. You can see the releases here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/modlfo/vult/releases&#34;&gt;https://github.com/modlfo/vult/releases&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can find there binaries for Windows, OSX and Linux.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Now Vult can be installed from npm</title>
      <link>http://modlfo.github.io/vult/blog/vult-in-npm/</link>
      <pubDate>Tue, 04 Oct 2016 19:22:30 +0300</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/vult-in-npm/</guid>
      <description>&lt;p&gt;In the last months I have been making many improvements to the Vult compiler. These improvements cannot be easily tried by the users due to the fact that for me creating binaries for all the platforms is very time consuming. Therefore, in order for the users to try the latests changes they need to compile Vult from the source code. Even though the process is well documented in the repository, this can be time consuming and difficult for people unfamiliar with the OCaml tools.&lt;/p&gt;

&lt;p&gt;I have been using &lt;code&gt;js_of_ocaml&lt;/code&gt; for quite some time to convert parts of the Vult compiler to JavaScript that runs in the live demo page &lt;a href=&#34;http://modlfo.github.io/vult/demo/&#34;&gt;http://modlfo.github.io/vult/demo/&lt;/a&gt; however the code there does not perform any I/O to disk since it&amp;rsquo;s intended to run in the web browser.&lt;/p&gt;

&lt;p&gt;I tried to convert the whole application to JavaScript to see if it could run (as it is) with the latest improvements of &lt;code&gt;js_of_ocaml&lt;/code&gt;. That way I can distribute a JavaScript version that can be run with node.js. Node.js has many advantages, for example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;runs in most platforms&lt;/li&gt;
&lt;li&gt;easy to install&lt;/li&gt;
&lt;li&gt;it has a good package manager&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fortunately, the only thing that did not work was the file I/O (which seems reasonable). In order to make it work I made a small hack that allowed me to switch the functions that read and write files. That way I can declare bindings for the node.js functions and replace them. Here&amp;rsquo;s the code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;(** Declares a &#39;buffer&#39; object *)
class type buffer = object
   method toString : js_string t meth
end

(** Declares a &#39;fs&#39; object *)
class type fs = object
   method readFileSync : js_string t -&amp;gt; buffer t meth
   method writeFileSync : js_string t -&amp;gt; js_string t -&amp;gt; unit t meth
end

(* var fs = require(&#39;fs&#39;) *)
let fs : fs t =
   Unsafe.fun_call (Unsafe.js_expr &amp;quot;require&amp;quot;)
      [|Unsafe.inject (string &amp;quot;fs&amp;quot;)|]

let read_fn (path:string) : string option =
   let buffer   = fs##readFileSync (string path) in
   let contents = to_string (buffer##toString ()) in
   Some(contents)

let write_fn (path:string) (text:string) : bool =
   let _ = fs##writeFileSync ((string path),(string text)) in
   true
;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then I replace the functions as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;FileIO.setRead read_fn ;;
FileIO.setWrite write_fn ;;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With those changes it&amp;rsquo;s possible to compile the bytecode and convert it to JavaScript. Now it&amp;rsquo;s possible to run the Vult compiler as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ node vultjs.js arguments
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thanks to the npm it is even easier to install Vult an run it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install vult -g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command will give you an &amp;ldquo;executable&amp;rdquo; that can be called simply as &lt;code&gt;vultc&lt;/code&gt;, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vultc -ccode infile.vult -o outfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the repository for the package &lt;a href=&#34;https://github.com/modlfo/vultjs&#34;&gt;https://github.com/modlfo/vultjs&lt;/a&gt; and this is the main page of the npm package &lt;a href=&#34;https://www.npmjs.com/package/vult&#34;&gt;https://www.npmjs.com/package/vult&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I will update the source code every time I think the changes in trunk are useful.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LuaJIT as backend for Vult</title>
      <link>http://modlfo.github.io/vult/blog/lua/</link>
      <pubDate>Thu, 08 Sep 2016 22:43:03 +0300</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/lua/</guid>
      <description>&lt;p&gt;I have been keeping an eye on LuaJIT (&lt;a href=&#34;http://luajit.org&#34;&gt;http://luajit.org&lt;/a&gt;) for some time. It&amp;rsquo;s a very interesting project and I have read very good things about it. Some time ago I made a small benchmark comparing an optimized algorithm written in C++11 against a lazy coded version in OCaml and LuaJIT. In case you are curious here are the results:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Language&lt;/th&gt;
&lt;th&gt;Execution Time&lt;/th&gt;
&lt;th&gt;Lines of Code&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;td&gt;0.355 s&lt;/td&gt;
&lt;td&gt;180&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;OCaml&lt;/td&gt;
&lt;td&gt;0.54 s&lt;/td&gt;
&lt;td&gt;63&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LuaJIT&lt;/td&gt;
&lt;td&gt;0.78 s&lt;/td&gt;
&lt;td&gt;85&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Here&amp;rsquo;s a chart that plots the lines of code against the execution time.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;../images/benchmark1.svg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;I have to remark again: &lt;em&gt;The OCaml and Lua code were not written with optimization in mind&lt;/em&gt;. My intention was to see how fast they program could go without putting too much effort coding.&lt;/p&gt;

&lt;p&gt;One can see that the C++ code is much larger. On the other hand, the OCaml code is very compact. The main reason was that in OCaml I used algebraic data types which neither Lua or C++ have (&lt;a href=&#34;https://en.wikipedia.org/wiki/Algebraic_data_type&#34;&gt;https://en.wikipedia.org/wiki/Algebraic_data_type&lt;/a&gt;). Therefore, all the complex data types needed to be implemented with classes or tables in the case of Lua.&lt;/p&gt;

&lt;p&gt;Recently I implemented a prototype of code generation Vult -&amp;gt; Lua in order to check if LuaJIT could be used to create a better live coding environment. I took the JavaScript generator and with a few modifications I got Lua support.&lt;/p&gt;

&lt;p&gt;To generate Lua code you need to call Vult as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./vultc.native -luacode code.vult -o code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to check the performance I took one of the examples I have in Vult and made a test rendering 1000 s of audio. Here are the results:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Language&lt;/th&gt;
&lt;th&gt;Execution Time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;td&gt;2.77 s&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LuaJIT&lt;/td&gt;
&lt;td&gt;3.55 s&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Here&amp;rsquo;s the graphic view:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;../images/benchmark2.svg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;The results are quite promising. The code was pure Lua with exception of the arrays which are implemented using the LuaJIT FFI as &lt;code&gt;double[]&lt;/code&gt;. One important thing to notice is that the LuaJIT performs all operations in &lt;code&gt;double&lt;/code&gt; precision, while the C/C++ uses &lt;code&gt;float&lt;/code&gt;. I&amp;rsquo;m not sure if this has a big impact or not in modern processors.&lt;/p&gt;

&lt;p&gt;As follow up in this topic, I&amp;rsquo;m planning to do more testing to see if I can generate code that is faster in LuaJIT taking advantage of the FFI features. I&amp;rsquo;m gonna try as well to find a nice way of integrating LuaJIT + Vult into a VST or a PD external.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generating Pure Data and Teensy Audio templates</title>
      <link>http://modlfo.github.io/vult/blog/pd-teensy/</link>
      <pubDate>Wed, 13 Jul 2016 20:10:57 +0200</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/pd-teensy/</guid>
      <description>&lt;p&gt;As part of the Vult project I have developed a new standalone library: Pla (&lt;a href=&#34;https://modlfo.github.io/pla/&#34;&gt;https://modlfo.github.io/pla/&lt;/a&gt;). Pla is a templating library that is used in Vult to generate code in a simpler way. Thanks to this library I have developed two templates to simplify using Vult:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/modlfo/pd-vult-example&#34;&gt;Pure Data externals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/modlfo/pd-vult-example&#34;&gt;Teensy Audio Library objects&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The template for Pure Data is more stable. It supports both, floating-point and fixed-point arithmetics. In addition, the number of inputs and outputs of the &amp;lsquo;external&amp;rsquo; matches the inputs and outputs of the &lt;code&gt;process&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;You can find an example of using it in this repository: &lt;a href=&#34;https://github.com/modlfo/pd-vult-example&#34;&gt;https://github.com/modlfo/pd-vult-example&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Exporting of objects for the Teensy Audio Library is only available in fixed-point and (currently) only supports synthesis objects (I have plans to make it as flexible as the PD template).&lt;/p&gt;

&lt;p&gt;Here you can find an example: &lt;a href=&#34;https://github.com/modlfo/teensy-vult-example&#34;&gt;https://github.com/modlfo/teensy-vult-example&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>New site for Vult</title>
      <link>http://modlfo.github.io/vult/blog/new-site/</link>
      <pubDate>Tue, 12 Jul 2016 20:21:43 +0200</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/new-site/</guid>
      <description>&lt;p&gt;I have been working on giving a refresh of the Vult site. The result is what you see now. After trying a few alternatives I settle to use Hugo (&lt;a href=&#34;https://gohugo.io&#34;&gt;https://gohugo.io&lt;/a&gt;). The reason I used Hugo was because I could make it do exactly what I wanted with the help of the documentation.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m very proud that I did the theme of the site from the ground up (that&amp;rsquo;s why is so minimalistic). I also added comments section using Google+, and I hope it works as expected.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>