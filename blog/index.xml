<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog-rsses on Vult by modlfo</title>
    <link>http://modlfo.github.io/vult/blog/index.xml</link>
    <description>Recent content in Blog-rsses on Vult by modlfo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 20 Jun 2017 08:40:42 +0300</lastBuildDate>
    <atom:link href="http://modlfo.github.io/vult/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Compile-time embedding of WAV files</title>
      <link>http://modlfo.github.io/vult/blog/embed-wav/</link>
      <pubDate>Tue, 20 Jun 2017 08:40:42 +0300</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/embed-wav/</guid>
      <description>&lt;p&gt;Around the 2000&amp;rsquo;s I got my first VST plugin; it was a PPG Wave. The sounds produced by this plugin got me intrigued because it sounded very different from other soft synths that I have heard. The main difference was that the PPG was based on wavetables. Since I started working on Vult, making a wavetable synthesizer has been in the list.&lt;/p&gt;

&lt;p&gt;To make a wavetable synthesizer you need waveforms. One of the things I considered was to extract the waves from the PPG ROM, but in the process of trying that I found the work of &lt;a href=&#34;https://www.adventurekid.se&#34;&gt;Adventure Kid&lt;/a&gt; who has created a large database of waveforms and impulse response files &lt;a href=&#34;https://www.adventurekid.se/AKRT/&#34;&gt;AKRT&lt;/a&gt;. He provides the wavetables and IR as WAV files.&lt;/p&gt;

&lt;p&gt;In order to use wavetables in Vult (as the ones provided by Adventure Kid) it&amp;rsquo;s necessary to load them in some way. Since Vult is all about the code, the easiest way is to include the wavetables in the code itself. To that purpose we have now a new tag &lt;code&gt;@[wave]&lt;/code&gt; that allows to specify a WAV file. The function marked with the tag is replaced at compile-time with a function that returns the data of the file. For example:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;snipet-1&#34;&gt;
external mywave(channel:int, index:int) : real
   @[wave(channels=1, file=&#34;wave.wav&#34;)];
&lt;/div&gt;

&lt;p&gt;The code above declares an external function called &lt;code&gt;mywave&lt;/code&gt;. The function must take as arguments two integers: the channel and the sample index. The tag &lt;code&gt;@[wave(channels=1, file=&amp;quot;wave.wav&amp;quot;)]&lt;/code&gt; specifies that the WAV file has one channel and that the file name is &lt;code&gt;wave.wav&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;While running, the Vult compiler will look for the file &lt;code&gt;wave.wav&lt;/code&gt; in the same location of the current file or in the include directories passed with the flag &lt;code&gt;-i&lt;/code&gt;. To access the data we can call the function providing the channel we want to read and the index of the sample as follows:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;snipet-2&#34;&gt;
fun fun() {
   val channel = 0; // first channel
   val sample = 0;  // first sample
   return mywave(channel, sample);
}
&lt;/div&gt;

&lt;p&gt;If we try to read a channel that does not exists the function will return zero. If we pass an index outside the range of the wav file, the mod (%) operation is used to fix the index. This will make it behave as a circular buffer.&lt;/p&gt;

&lt;p&gt;The tag also generates a new function with the name &lt;code&gt;&amp;lt;name&amp;gt;_samples()&lt;/code&gt; that returns the number of samples in the WAV file. In the case above, the function will be called &lt;code&gt;mywave_samples()&lt;/code&gt;. If another function with the same name exists we will get a compilation error.&lt;/p&gt;

&lt;p&gt;As a complete example, the following code will play back in a loop the embedded wave file.&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;snipet-3&#34;&gt;
external mywave(channel:int, index:int) : real
   @[wave(channels=1, file=&#34;wave.wav&#34;)];

// count from 0 to the number of samples in file &#34;wave.wav&#34; minus one
fun index() {
   // use mywave_samples() to reset the counter to zero
   mem i = (i + 1) % mywave_samples();
   return i;
}

fun play() {
   return mywave(0, index());
}
&lt;/div&gt;

&lt;p&gt;Currently, only PCM WAV files in 16 and 24 bits are supported.&lt;/p&gt;

&lt;p&gt;Embedding of WAV files is intended to handle short WAV files (a few seconds or less). Embedding very large files slows down the code generation and I might cause both, the Vult compiler and target compiler to fail. For such cases is recommended to provide an external function that reads at run-time the file.&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/external/ace/ace.js&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/main.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Compile-time creation of tables</title>
      <link>http://modlfo.github.io/vult/blog/tables/</link>
      <pubDate>Wed, 01 Feb 2017 22:04:23 +0100</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/tables/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;
   src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&#34;&gt;
&lt;/script&gt;

&lt;p&gt;This is one of the features that has been in the TODO list since the creation of Vult. When generating code, now is possible to annotate a function and Vult will automatically create a table-based implementation which will be faster. This is specially useful when generating code for microcontrollers.&lt;/p&gt;

&lt;p&gt;As an example, take the function used to convert from pitch (MIDI note number) to frequency.&lt;/p&gt;

&lt;div&gt;$$f = 440 \cdot 2^{ \frac {d - 69} {12}} $$&lt;/div&gt;

&lt;p&gt;Using that formula, we can calculate the &lt;code&gt;rate&lt;/code&gt; of increment for a saw wave at a certain sampling frequency. For example, to produce a saw wave with pitch &lt;code&gt;d&lt;/code&gt; at a sampling rate of 44100 Hz, you need to increment a counter at a &lt;code&gt;rate&lt;/code&gt; to reach a value of &lt;code&gt;1.0&lt;/code&gt;. Here&amp;rsquo;s the formula:&lt;/p&gt;

&lt;div&gt;$$rate = \frac {440 \cdot 2^{ \frac {d - 69} {12}}} {44100} $$&lt;/div&gt;

&lt;p&gt;This formula can be simplified (using Mathematica) to:&lt;/p&gt;

&lt;div&gt;$$rate = 0.00018539226566085504 \cdot e^{0.057762265046662105 \cdot d} $$&lt;/div&gt;

&lt;p&gt;We can see that the formula uses an exponential. Calculating an exponential every sample can be quite heavy in a microntroller (for example when making modulations). To alleviate that problem, we can annotate the function in Vult as follows:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;snipet-1&#34;&gt;fun pitchToRate(d) @[table(size=127,min=0.0,max=127.0)] {
   return 0.00018539226566085504 * exp(0.057762265046662105 * d);
}
&lt;/div&gt;

&lt;p&gt;The tag &lt;code&gt;@[table(size=128,min=0.0,max=127.0)]&lt;/code&gt; specifies that the function needs to be converted to a table of size &lt;code&gt;128&lt;/code&gt;, with a minimum value of &lt;code&gt;0.0&lt;/code&gt; and a maximum of &lt;code&gt;127.0&lt;/code&gt;. In this case Vult will split the range of the function into 128 segments and for each segment a second order polynomial that fits the values is calculated. All the coefficients are precalculated. The above function will be replaced by the following code (for a size 8 table):&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;snipet-2&#34;&gt;
// Precalculated Coefficients
val pitchToRate_c0 = [0.000185392265661,0.000552833927475,0.00450645672882,0.0293666851807,0.154117332865,0.706561261141,2.96582942265,11.7094517663];
val pitchToRate_c1 = [9.2285157274e-06,-2.89774227687e-05,-0.000240335947519,-0.0011351335136,-0.00451980896512,-0.0165475723334,-0.0576226599653,-0.194080429312];
val pitchToRate_c2 = [5.34353264823e-07,1.52390239335e-06,4.34596110343e-06,1.2394086389e-05,3.53462384489e-05,0.000100802635463,0.000287475325559,0.000819840280938];
// function with the new body
fun pitchToRate(d){
   val index = clip(int(0.0551181102362 * d),0,127);
   return get(pitchToRate_c0,index) + d * (get(pitchToRate_c1,index) + get(pitchToRate_c2,index) * d);
}
&lt;/div&gt;

&lt;p&gt;This new function is much faster that the one using the exponential. Thanks to this optimization I can run more complex code in the Teensy.&lt;/p&gt;

&lt;p&gt;One cool thing is about this feature is that it can convert any function of one input and one output to a table. For example, in the following program the function &lt;code&gt;wave_table&lt;/code&gt; is replaced by a table avoiding calculating three &lt;code&gt;sine&lt;/code&gt; functions.&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;snipet-3&#34;&gt;fun pitchToRate(d) @[table(size=127,min=0.0,max=127.0)] {
   return 0.00018539226566085504 * exp(0.057762265046662105 * d);
}

fun phasor(pitch){
    mem phase;
    val rate = pitchToRate(pitch);
    phase = (phase + rate) % 1.0;
    return phase;
}

fun wave_table(x) @[table(size=127,min=0.0,max=4.0)] {
    val pi = 3.14159265359;
    return (sin(2.0*pi*x) + sin(2.0*pi*x*2.0) + sin(2.0*pi*x*4.0))/3.0;
}
&lt;/div&gt;

&lt;p&gt;This feature works as well with fixed-point code. In one of the benchmarks that I ran I got the following results:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Representation&lt;/th&gt;
&lt;th&gt;No tables&lt;/th&gt;
&lt;th&gt;With tables&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Floating-point&lt;/td&gt;
&lt;td&gt;1.57 s&lt;/td&gt;
&lt;td&gt;1.11 s&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Fixed-point&lt;/td&gt;
&lt;td&gt;3.10 s&lt;/td&gt;
&lt;td&gt;0.94 s&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We can see that for fixed-point it really had a impact in the performance. The benchmark now runs 3 times faster.&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/external/ace/ace.js&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/main.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Automatic loading of Vult files</title>
      <link>http://modlfo.github.io/vult/blog/automatic-loading/</link>
      <pubDate>Thu, 01 Dec 2016 15:49:04 -0600</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/automatic-loading/</guid>
      <description>

&lt;p&gt;Recently I implemented simpler way to call the Vult compiler with multiple files. Previously Vult required that you passed every file in a correct order. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vultc -ccode file1.vult file2.vult
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case the &lt;code&gt;file2.vult&lt;/code&gt; used functions from the &lt;code&gt;file1.vult&lt;/code&gt;. As the number of files increased it also increased the complexity of the call to the compiler.&lt;/p&gt;

&lt;p&gt;Compiling code now is easier. With the latest Vult compiler you just have to pass as argument your top file. In the previous example the call would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vultc -ccode file2.vult
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Based on the dependencies Vult will look for the corresponding files matching the convention that every module name  (for example &lt;code&gt;Util&lt;/code&gt;) has a corresponding file called &lt;code&gt;util.vult&lt;/code&gt;. Vult will look for the matching files in all the directories of the input files. For example the call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vultc /home/leonardo/dir1/file1.vult /home/leonardo/dir2/file2.vult
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will look for dependencies in the directories:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/home/leonardo/dir1/
/home/leonardo/dir2/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One important thing to notice is that the file order does not matter anymore.&lt;/p&gt;

&lt;p&gt;Vult will also look for files in the current working directory.&lt;/p&gt;

&lt;p&gt;If you want to add more directories to the search you can use the flag &lt;code&gt;-i&lt;/code&gt;. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vultc file1.vult -i /home/leonardo/dir2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;implementation&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;Solving this problem is in fact very easy. When a file is loaded first it&amp;rsquo;s necessary to get all its dependencies. Once the dependencies are detected, we need to look for the matching files in the implicit and explicit search locations. The same process is repeated until every file has been loaded. At this point, we have a list of all the necessary files. Now we have to load every file in the correct order because Vult does not support forward declarations of functions. To determine the order we can use topological sorting of the dependency graph.&lt;/p&gt;

&lt;p&gt;The actual implementation uses the &lt;a href=&#34;http://www.geeksforgeeks.org/strongly-connected-components/&#34;&gt;Strongly Connected Components&lt;/a&gt; algorithm. The reason of using this instead of simple &lt;a href=&#34;https://en.wikipedia.org/wiki/Topological_sorting&#34;&gt;Topological sorting&lt;/a&gt; is that the Strongly Connected Components algorithm will tell us if there are any cyclical dependencies, which is an error in Vult.&lt;/p&gt;

&lt;p&gt;You can find the complete implementation in OCaml in the file &lt;a href=&#34;https://github.com/modlfo/vult/blob/master/src/util/components.ml&#34;&gt;src/util/components.ml&lt;/a&gt;. The actual implementation of the Kosaraju&amp;rsquo;s algorithm is very compact, less than 40 lines of code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>New repository with more PureData examples</title>
      <link>http://modlfo.github.io/vult/blog/more-examples/</link>
      <pubDate>Tue, 01 Nov 2016 22:14:59 +0200</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/more-examples/</guid>
      <description>&lt;p&gt;A new repository with more Vult examples is available:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/modlfo/vult-examples&#34;&gt;https://github.com/modlfo/vult-examples&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This repository contains a set of standalone Vult files that can be easily compiled as PureData objects.&lt;/p&gt;

&lt;p&gt;The main idea behind this objects is to create collection of &amp;ldquo;modules&amp;rdquo; that try to follow the Eurorack voltage convention: the inputs are controlled by voltages. The oscillators follow the convention of 1 volt per octave. Parameters use a range of 0-5 volts.&lt;/p&gt;

&lt;p&gt;The repository also contains a few objects called &amp;ldquo;units&amp;rdquo; that are more complex modules composed with smaller objects, for example: a drum and mono synthesizer.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generating up-to-date binaries with CI</title>
      <link>http://modlfo.github.io/vult/blog/ci-integration/</link>
      <pubDate>Tue, 18 Oct 2016 22:56:13 +0300</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/ci-integration/</guid>
      <description>&lt;p&gt;I have been using Travis CI for running tests and checking that Vult build correctly. Travis CI can build Vult in OSX and Linux. However, due to the status of OCaml it was difficult to setup something similar in Windows with AppVeyor. Thankfully the OCaml community has published a set of script to configure different CI services:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ocaml/ocaml-ci-scripts&#34;&gt;https://github.com/ocaml/ocaml-ci-scripts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using those scripts I could get the AppVeyor continuous integration working. Here you can take a look at the status of both services:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ci.appveyor.com/project/modlfo/vult&#34;&gt;https://ci.appveyor.com/project/modlfo/vult&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://travis-ci.org/modlfo/vult&#34;&gt;https://travis-ci.org/modlfo/vult&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once I got the things working. I started a long run of commits to get the CI services to deploy automatically every tag as a Github release. More than 30 commits later I got it working. You can see the releases here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/modlfo/vult/releases&#34;&gt;https://github.com/modlfo/vult/releases&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can find there binaries for Windows, OSX and Linux.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Now Vult can be installed from npm</title>
      <link>http://modlfo.github.io/vult/blog/vult-in-npm/</link>
      <pubDate>Tue, 04 Oct 2016 19:22:30 +0300</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/vult-in-npm/</guid>
      <description>&lt;p&gt;In the last months I have been making many improvements to the Vult compiler. These improvements cannot be easily tried by the users due to the fact that for me creating binaries for all the platforms is very time consuming. Therefore, in order for the users to try the latests changes they need to compile Vult from the source code. Even though the process is well documented in the repository, this can be time consuming and difficult for people unfamiliar with the OCaml tools.&lt;/p&gt;

&lt;p&gt;I have been using &lt;code&gt;js_of_ocaml&lt;/code&gt; for quite some time to convert parts of the Vult compiler to JavaScript that runs in the live demo page &lt;a href=&#34;http://modlfo.github.io/vult/demo/&#34;&gt;http://modlfo.github.io/vult/demo/&lt;/a&gt; however the code there does not perform any I/O to disk since it&amp;rsquo;s intended to run in the web browser.&lt;/p&gt;

&lt;p&gt;I tried to convert the whole application to JavaScript to see if it could run (as it is) with the latest improvements of &lt;code&gt;js_of_ocaml&lt;/code&gt;. That way I can distribute a JavaScript version that can be run with node.js. Node.js has many advantages, for example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;runs in most platforms&lt;/li&gt;
&lt;li&gt;easy to install&lt;/li&gt;
&lt;li&gt;it has a good package manager&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fortunately, the only thing that did not work was the file I/O (which seems reasonable). In order to make it work I made a small hack that allowed me to switch the functions that read and write files. That way I can declare bindings for the node.js functions and replace them. Here&amp;rsquo;s the code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;(** Declares a &#39;buffer&#39; object *)
class type buffer = object
   method toString : js_string t meth
end

(** Declares a &#39;fs&#39; object *)
class type fs = object
   method readFileSync : js_string t -&amp;gt; buffer t meth
   method writeFileSync : js_string t -&amp;gt; js_string t -&amp;gt; unit t meth
end

(* var fs = require(&#39;fs&#39;) *)
let fs : fs t =
   Unsafe.fun_call (Unsafe.js_expr &amp;quot;require&amp;quot;)
      [|Unsafe.inject (string &amp;quot;fs&amp;quot;)|]

let read_fn (path:string) : string option =
   let buffer   = fs##readFileSync (string path) in
   let contents = to_string (buffer##toString ()) in
   Some(contents)

let write_fn (path:string) (text:string) : bool =
   let _ = fs##writeFileSync ((string path),(string text)) in
   true
;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then I replace the functions as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;FileIO.setRead read_fn ;;
FileIO.setWrite write_fn ;;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With those changes it&amp;rsquo;s possible to compile the bytecode and convert it to JavaScript. Now it&amp;rsquo;s possible to run the Vult compiler as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ node vultjs.js arguments
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thanks to the npm it is even easier to install Vult an run it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install vult -g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command will give you an &amp;ldquo;executable&amp;rdquo; that can be called simply as &lt;code&gt;vultc&lt;/code&gt;, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vultc -ccode infile.vult -o outfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the repository for the package &lt;a href=&#34;https://github.com/modlfo/vultjs&#34;&gt;https://github.com/modlfo/vultjs&lt;/a&gt; and this is the main page of the npm package &lt;a href=&#34;https://www.npmjs.com/package/vult&#34;&gt;https://www.npmjs.com/package/vult&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I will update the source code every time I think the changes in trunk are useful.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LuaJIT as backend for Vult</title>
      <link>http://modlfo.github.io/vult/blog/lua/</link>
      <pubDate>Thu, 08 Sep 2016 22:43:03 +0300</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/lua/</guid>
      <description>&lt;p&gt;I have been keeping an eye on LuaJIT (&lt;a href=&#34;http://luajit.org&#34;&gt;http://luajit.org&lt;/a&gt;) for some time. It&amp;rsquo;s a very interesting project and I have read very good things about it. Some time ago I made a small benchmark comparing an optimized algorithm written in C++11 against a lazy coded version in OCaml and LuaJIT. In case you are curious here are the results:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Language&lt;/th&gt;
&lt;th&gt;Execution Time&lt;/th&gt;
&lt;th&gt;Lines of Code&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;td&gt;0.355 s&lt;/td&gt;
&lt;td&gt;180&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;OCaml&lt;/td&gt;
&lt;td&gt;0.54 s&lt;/td&gt;
&lt;td&gt;63&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LuaJIT&lt;/td&gt;
&lt;td&gt;0.78 s&lt;/td&gt;
&lt;td&gt;85&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Here&amp;rsquo;s a chart that plots the lines of code against the execution time.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;../images/benchmark1.svg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;I have to remark again: &lt;em&gt;The OCaml and Lua code were not written with optimization in mind&lt;/em&gt;. My intention was to see how fast they program could go without putting too much effort coding.&lt;/p&gt;

&lt;p&gt;One can see that the C++ code is much larger. On the other hand, the OCaml code is very compact. The main reason was that in OCaml I used algebraic data types which neither Lua or C++ have (&lt;a href=&#34;https://en.wikipedia.org/wiki/Algebraic_data_type&#34;&gt;https://en.wikipedia.org/wiki/Algebraic_data_type&lt;/a&gt;). Therefore, all the complex data types needed to be implemented with classes or tables in the case of Lua.&lt;/p&gt;

&lt;p&gt;Recently I implemented a prototype of code generation Vult -&amp;gt; Lua in order to check if LuaJIT could be used to create a better live coding environment. I took the JavaScript generator and with a few modifications I got Lua support.&lt;/p&gt;

&lt;p&gt;To generate Lua code you need to call Vult as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./vultc.native -luacode code.vult -o code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to check the performance I took one of the examples I have in Vult and made a test rendering 1000 s of audio. Here are the results:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Language&lt;/th&gt;
&lt;th&gt;Execution Time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;td&gt;2.77 s&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LuaJIT&lt;/td&gt;
&lt;td&gt;3.55 s&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Here&amp;rsquo;s the graphic view:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;../images/benchmark2.svg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;The results are quite promising. The code was pure Lua with exception of the arrays which are implemented using the LuaJIT FFI as &lt;code&gt;double[]&lt;/code&gt;. One important thing to notice is that the LuaJIT performs all operations in &lt;code&gt;double&lt;/code&gt; precision, while the C/C++ uses &lt;code&gt;float&lt;/code&gt;. I&amp;rsquo;m not sure if this has a big impact or not in modern processors.&lt;/p&gt;

&lt;p&gt;As follow up in this topic, I&amp;rsquo;m planning to do more testing to see if I can generate code that is faster in LuaJIT taking advantage of the FFI features. I&amp;rsquo;m gonna try as well to find a nice way of integrating LuaJIT + Vult into a VST or a PD external.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generating Pure Data and Teensy Audio templates</title>
      <link>http://modlfo.github.io/vult/blog/pd-teensy/</link>
      <pubDate>Wed, 13 Jul 2016 20:10:57 +0200</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/pd-teensy/</guid>
      <description>&lt;p&gt;As part of the Vult project I have developed a new standalone library: Pla (&lt;a href=&#34;https://modlfo.github.io/pla/&#34;&gt;https://modlfo.github.io/pla/&lt;/a&gt;). Pla is a templating library that is used in Vult to generate code in a simpler way. Thanks to this library I have developed two templates to simplify using Vult:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/modlfo/pd-vult-example&#34;&gt;Pure Data externals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/modlfo/pd-vult-example&#34;&gt;Teensy Audio Library objects&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The template for Pure Data is more stable. It supports both, floating-point and fixed-point arithmetics. In addition, the number of inputs and outputs of the &amp;lsquo;external&amp;rsquo; matches the inputs and outputs of the &lt;code&gt;process&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;You can find an example of using it in this repository: &lt;a href=&#34;https://github.com/modlfo/pd-vult-example&#34;&gt;https://github.com/modlfo/pd-vult-example&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Exporting of objects for the Teensy Audio Library is only available in fixed-point and (currently) only supports synthesis objects (I have plans to make it as flexible as the PD template).&lt;/p&gt;

&lt;p&gt;Here you can find an example: &lt;a href=&#34;https://github.com/modlfo/teensy-vult-example&#34;&gt;https://github.com/modlfo/teensy-vult-example&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>New site for Vult</title>
      <link>http://modlfo.github.io/vult/blog/new-site/</link>
      <pubDate>Tue, 12 Jul 2016 20:21:43 +0200</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/new-site/</guid>
      <description>&lt;p&gt;I have been working on giving a refresh of the Vult site. The result is what you see now. After trying a few alternatives I settle to use Hugo (&lt;a href=&#34;https://gohugo.io&#34;&gt;https://gohugo.io&lt;/a&gt;). The reason I used Hugo was because I could make it do exactly what I wanted with the help of the documentation.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m very proud that I did the theme of the site from the ground up (that&amp;rsquo;s why is so minimalistic). I also added comments section using Google+, and I hope it works as expected.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>