<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Vult by modlfo</title>
    <link>http://modlfo.github.io/vult/index.xml</link>
    <description>Recent content on Vult by modlfo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 01 Dec 2016 15:49:04 -0600</lastBuildDate>
    <atom:link href="http://modlfo.github.io/vult/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Automatic loading of Vult files</title>
      <link>http://modlfo.github.io/vult/blog/automatic-loading/</link>
      <pubDate>Thu, 01 Dec 2016 15:49:04 -0600</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/automatic-loading/</guid>
      <description>

&lt;p&gt;Recently I implemented simpler way to call the Vult compiler with multiple files. Previously Vult required that you passed every file in a correct order. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vultc -ccode file1.vult file2.vult
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case the &lt;code&gt;file2.vult&lt;/code&gt; used functions from the &lt;code&gt;file1.vult&lt;/code&gt;. As the number of files increased it also increased the complexity of the call to the compiler.&lt;/p&gt;

&lt;p&gt;Compiling code now is easier. With the latest Vult compiler you just have to pass as argument your top file. In the previous example the call would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vultc -ccode file2.vult
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Based on the dependencies Vult will look for the corresponding files matching the convention that every module name  (for example &lt;code&gt;Util&lt;/code&gt;) has a corresponding file called &lt;code&gt;util.vult&lt;/code&gt;. Vult will look for the matching files in all the directories of the input files. For example the call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vultc /home/leonardo/dir1/file1.vult /home/leonardo/dir2/file2.vult
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will look for dependencies in the directories:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/home/leonardo/dir1/
/home/leonardo/dir2/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One important thing to notice is that the file order does not matter anymore.&lt;/p&gt;

&lt;p&gt;Vult will also look for files in the current working directory.&lt;/p&gt;

&lt;p&gt;If you want to add more directories to the search you can use the flag &lt;code&gt;-i&lt;/code&gt;. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vultc file1.vult -i /home/leonardo/dir2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;implementation&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;Solving this problem is in fact very easy. When a file is loaded first it&amp;rsquo;s necessary to get all its dependencies. Once the dependencies are detected, we need to look for the matching files in the implicit and explicit search locations. The same process is repeated until every file has been loaded. At this point, we have a list of all the necessary files. Now we have to load every file in the correct order because Vult does not support forward declarations of functions. To determine the order we can use topological sorting of the dependency graph.&lt;/p&gt;

&lt;p&gt;The actual implementation uses the &lt;a href=&#34;http://www.geeksforgeeks.org/strongly-connected-components/&#34;&gt;Strongly Connected Components&lt;/a&gt; algorithm. The reason of using this instead of simple &lt;a href=&#34;https://en.wikipedia.org/wiki/Topological_sorting&#34;&gt;Topological sorting&lt;/a&gt; is that the Strongly Connected Components algorithm will tell us if there are any cyclical dependencies, which is an error in Vult.&lt;/p&gt;

&lt;p&gt;You can find the complete implementation in OCaml in the file &lt;a href=&#34;https://github.com/modlfo/vult/blob/master/src/util/components.ml&#34;&gt;src/util/components.ml&lt;/a&gt;. The actual implementation of the Kosaraju&amp;rsquo;s algorithm is very compact, less than 40 lines of code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vult Language Basics</title>
      <link>http://modlfo.github.io/vult/tutorials/basics/</link>
      <pubDate>Thu, 01 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://modlfo.github.io/vult/tutorials/basics/</guid>
      <description>&lt;p&gt;Vult has syntax that may resemble languages like C/C++, Python or JavaScript. In order to declare a function you can use the keyword &lt;code&gt;fun&lt;/code&gt; as follows:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut1-0&#34;&gt;fun foo() return 0;
&lt;/div&gt;

&lt;p&gt;This functions takes no arguments and returns the integer value zero. If you have more than one statement you can use the curly braces &lt;code&gt;{}&lt;/code&gt; to delimit the function body.&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut1-1&#34;&gt;fun foo(x) {
   val y = 1 + x;
   return y;
}
&lt;/div&gt;

&lt;p&gt;As you may have seen, you can declare variables with the keyword &lt;code&gt;val&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Vult is a static language, this means that every variable has concrete type. Since Vult is focused on numeric computations there are two main types available: &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt;. You can specify the type of the variables with colon &lt;code&gt;:&lt;/code&gt; as follows:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut1-2&#34;&gt;fun foo(x : int) : int {
   val y : int = 1 + x;
   return y;
}
&lt;/div&gt;

&lt;p&gt;This specifies that the function receives an argument &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;int&lt;/code&gt; and returns a value of type &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The type annotations are not strictly necessary. Vult has type inference which means that it will try to automatically determine every type based on the use of the variables. We will cover more about the type inference in a different tutorial.&lt;/p&gt;

&lt;p&gt;Function in Vult can return multiple values separated by commas. The values can be assigned to multiple variables in a similar way.&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut1-3&#34;&gt;fun foo() {
   return 1, 2;
}

fun bar(){
   val a, b = foo();
}
&lt;/div&gt;

&lt;p&gt;As mentioned before, Vult is static and strict. It is not possible to mix operations between reals and integers without making an explicit cast. The following operation is invalid:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut1-4&#34;&gt;fun foo() {
   val x = 1;
   val y = 2.1;
   return x + y; // invalid operation
}
&lt;/div&gt;

&lt;p&gt;The problem here is that the values have different type. The number &lt;code&gt;1&lt;/code&gt; is of type &lt;code&gt;int&lt;/code&gt; and the number &lt;code&gt;2.1&lt;/code&gt; is of type &lt;code&gt;real&lt;/code&gt;. In order to perform operations, you need to explicitly cast the values. For example:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut1-5&#34;&gt;fun foo() {
   val x = 1;
   val y = 2.1;
   val z = x + int(y);  // z = 3
   val w = real(x) + y; // w = 3.1
   return w;
}
&lt;/div&gt;

&lt;p&gt;By not making automatic conversion of types Vult gives you a more control on the kind of operation you want to perform.&lt;/p&gt;

&lt;p&gt;In the following tutorials we will cover more advanced aspects of Vult.&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/external/ace/ace.js&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/main.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>New repository with more PureData examples</title>
      <link>http://modlfo.github.io/vult/blog/more-examples/</link>
      <pubDate>Tue, 01 Nov 2016 22:14:59 +0200</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/more-examples/</guid>
      <description>&lt;p&gt;A new repository with more Vult examples is available:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/modlfo/vult-examples&#34;&gt;https://github.com/modlfo/vult-examples&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This repository contains a set of standalone Vult files that can be easily compiled as PureData objects.&lt;/p&gt;

&lt;p&gt;The main idea behind this objects is to create collection of &amp;ldquo;modules&amp;rdquo; that try to follow the Eurorack voltage convention: the inputs are controlled by voltages. The oscillators follow the convention of 1 volt per octave. Parameters use a range of 0-5 volts.&lt;/p&gt;

&lt;p&gt;The repository also contains a few objects called &amp;ldquo;units&amp;rdquo; that are more complex modules composed with smaller objects, for example: a drum and mono synthesizer.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Functions with Memory</title>
      <link>http://modlfo.github.io/vult/tutorials/functions/</link>
      <pubDate>Tue, 01 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://modlfo.github.io/vult/tutorials/functions/</guid>
      <description>&lt;p&gt;Vult has two types of functions: passive and active. Passive functions are like the examples that we saw in the Vult Language Basics, for example:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut2-0&#34;&gt;fun square(x) {
   return x * x;
}
&lt;/div&gt;

&lt;p&gt;These functions simply receive arguments, perform computations and return a value.&lt;/p&gt;

&lt;p&gt;One of the most useful features of Vult are the active functions. These functions have the characteristic that have internal and independent memory variables. The memory variables are declared with the keyword &lt;code&gt;mem&lt;/code&gt;. For example, if we would like to make a counter in Vult we could write the following function:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut2-1&#34;&gt;fun counter(n) {
   mem count;         // our memory variable
   count = count + n; // increases the value by &#39;n&#39; and updates it
   return count;      // returns the new count
}

fun loop() {
   val x = counter(1); // every time count is called the value increases 1
}
&lt;/div&gt;

&lt;p&gt;In the code shown above, let&amp;rsquo;s assume that an external function calls repeatedly the function &lt;code&gt;loop&lt;/code&gt;. Every time the function &lt;code&gt;loop&lt;/code&gt; is called, the function &lt;code&gt;counter&lt;/code&gt; is called and increases the value of the memory variable &lt;code&gt;count&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;One very important thing to note is that every call to an active function creates a new context.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;For example, if we have the following code:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut2-3&#34;&gt;fun loop() {
   val first = counter(1);   // first counter, increases by 1
   val second = counter(10); // second counter, increases by 10
}
&lt;/div&gt;

&lt;p&gt;the first call to &lt;code&gt;counter&lt;/code&gt; creates it&amp;rsquo;s own &lt;code&gt;count&lt;/code&gt; variable and is not affected by the second call. So the values of &lt;code&gt;first&lt;/code&gt; will be &lt;code&gt;1, 2, 3 ...&lt;/code&gt; while the values of &lt;code&gt;second&lt;/code&gt; will be &lt;code&gt;10, 20, 30, ...&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Another example of using functions with memory is the following:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut2-4&#34;&gt;// Returns &#39;true&#39; every &#39;n&#39; calls
fun every(n) {
   // increments the variable and returns it to 0 when larger than n
   mem count = (count + 1) % n;
   // Return true if the variable is zero
   return (count == 0);
}
&lt;/div&gt;

&lt;p&gt;This function returns &lt;code&gt;true&lt;/code&gt; every &lt;code&gt;n&lt;/code&gt; times is called. This can be used to limit the number of times an expensive computation is performed. For example:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut2-5&#34;&gt;
fun loop(){
   if(every(10)) {
      .... // perform an expensive computation
   }
}
&lt;/div&gt;

&lt;p&gt;Other function that can be very useful is:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut2-6&#34;&gt;// Returns &#39;true&#39; if the input value changes
fun change(current) {
   mem previous;
   val result = current &lt;&gt; previous;
   previous = current;
   return result;
}
&lt;/div&gt;

&lt;p&gt;In this case, the function returns &lt;code&gt;true&lt;/code&gt; every time it&amp;rsquo;s value changes compared to its previous value.&lt;/p&gt;

&lt;p&gt;In the following tutorial we will see more advanced use cases focusing on a DSP application.&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/external/ace/ace.js&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/main.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Generating up-to-date binaries with CI</title>
      <link>http://modlfo.github.io/vult/blog/ci-integration/</link>
      <pubDate>Tue, 18 Oct 2016 22:56:13 +0300</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/ci-integration/</guid>
      <description>&lt;p&gt;I have been using Travis CI for running tests and checking that Vult build correctly. Travis CI can build Vult in OSX and Linux. However, due to the status of OCaml it was difficult to setup something similar in Windows with AppVeyor. Thankfully the OCaml community has published a set of script to configure different CI services:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ocaml/ocaml-ci-scripts&#34;&gt;https://github.com/ocaml/ocaml-ci-scripts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using those scripts I could get the AppVeyor continuous integration working. Here you can take a look at the status of both services:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ci.appveyor.com/project/modlfo/vult&#34;&gt;https://ci.appveyor.com/project/modlfo/vult&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://travis-ci.org/modlfo/vult&#34;&gt;https://travis-ci.org/modlfo/vult&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once I got the things working. I started a long run of commits to get the CI services to deploy automatically every tag as a Github release. More than 30 commits later I got it working. You can see the releases here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/modlfo/vult/releases&#34;&gt;https://github.com/modlfo/vult/releases&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can find there binaries for Windows, OSX and Linux.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Now Vult can be installed from npm</title>
      <link>http://modlfo.github.io/vult/blog/vult-in-npm/</link>
      <pubDate>Tue, 04 Oct 2016 19:22:30 +0300</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/vult-in-npm/</guid>
      <description>&lt;p&gt;In the last months I have been making many improvements to the Vult compiler. These improvements cannot be easily tried by the users due to the fact that for me creating binaries for all the platforms is very time consuming. Therefore, in order for the users to try the latests changes they need to compile Vult from the source code. Even though the process is well documented in the repository, this can be time consuming and difficult for people unfamiliar with the OCaml tools.&lt;/p&gt;

&lt;p&gt;I have been using &lt;code&gt;js_of_ocaml&lt;/code&gt; for quite some time to convert parts of the Vult compiler to JavaScript that runs in the live demo page &lt;a href=&#34;http://modlfo.github.io/vult/demo/&#34;&gt;http://modlfo.github.io/vult/demo/&lt;/a&gt; however the code there does not perform any I/O to disk since it&amp;rsquo;s intended to run in the web browser.&lt;/p&gt;

&lt;p&gt;I tried to convert the whole application to JavaScript to see if it could run (as it is) with the latest improvements of &lt;code&gt;js_of_ocaml&lt;/code&gt;. That way I can distribute a JavaScript version that can be run with node.js. Node.js has many advantages, for example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;runs in most platforms&lt;/li&gt;
&lt;li&gt;easy to install&lt;/li&gt;
&lt;li&gt;it has a good package manager&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fortunately, the only thing that did not work was the file I/O (which seems reasonable). In order to make it work I made a small hack that allowed me to switch the functions that read and write files. That way I can declare bindings for the node.js functions and replace them. Here&amp;rsquo;s the code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;(** Declares a &#39;buffer&#39; object *)
class type buffer = object
   method toString : js_string t meth
end

(** Declares a &#39;fs&#39; object *)
class type fs = object
   method readFileSync : js_string t -&amp;gt; buffer t meth
   method writeFileSync : js_string t -&amp;gt; js_string t -&amp;gt; unit t meth
end

(* var fs = require(&#39;fs&#39;) *)
let fs : fs t =
   Unsafe.fun_call (Unsafe.js_expr &amp;quot;require&amp;quot;)
      [|Unsafe.inject (string &amp;quot;fs&amp;quot;)|]

let read_fn (path:string) : string option =
   let buffer   = fs##readFileSync (string path) in
   let contents = to_string (buffer##toString ()) in
   Some(contents)

let write_fn (path:string) (text:string) : bool =
   let _ = fs##writeFileSync ((string path),(string text)) in
   true
;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then I replace the functions as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ocaml&#34;&gt;FileIO.setRead read_fn ;;
FileIO.setWrite write_fn ;;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With those changes it&amp;rsquo;s possible to compile the bytecode and convert it to JavaScript. Now it&amp;rsquo;s possible to run the Vult compiler as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ node vultjs.js arguments
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thanks to the npm it is even easier to install Vult an run it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install vult -g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command will give you an &amp;ldquo;executable&amp;rdquo; that can be called simply as &lt;code&gt;vultc&lt;/code&gt;, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vultc -ccode infile.vult -o outfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the repository for the package &lt;a href=&#34;https://github.com/modlfo/vultjs&#34;&gt;https://github.com/modlfo/vultjs&lt;/a&gt; and this is the main page of the npm package &lt;a href=&#34;https://www.npmjs.com/package/vult&#34;&gt;https://www.npmjs.com/package/vult&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I will update the source code every time I think the changes in trunk are useful.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Easy DSP with Vult</title>
      <link>http://modlfo.github.io/vult/tutorials/dsp/</link>
      <pubDate>Sat, 01 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://modlfo.github.io/vult/tutorials/dsp/</guid>
      <description>&lt;p&gt;Functions with memory simplify writing Digital Signal Processing (DSP) code since a &lt;code&gt;mem&lt;/code&gt; variable can be used to as a single sample delay &lt;code&gt;z^1&lt;/code&gt;. I order to implement the Digital Biquad Filter (direct form 2) we can take the equations directly from Wikipedia: &lt;a href=&#34;https://en.wikipedia.org/wiki/Digital_biquad_filter&#34;&gt;https://en.wikipedia.org/wiki/Digital_biquad_filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We can see the architecture and the equations here:&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;./images/biquad-df2-eq1.svg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;./images/biquad-df2-eq2.svg&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;./images/biquad-df2-image.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;We can implement these equations in Vult as follows.&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut3-1&#34;&gt;fun biquad(x0, b0, b1, b2 ,a1 ,a2) : real {
    mem w1, w2;
    val w0 = x0 - a1*w1 - a2*w2;
    val y0 = b0*w0 + b1*w1 + b2*w2;
    w2, w1 = w1, w0;
    return y0;
}
&lt;/div&gt;

&lt;p&gt;The variables &lt;code&gt;w1&lt;/code&gt; and &lt;code&gt;w2&lt;/code&gt; represent the terms &lt;code&gt;w[n-1]&lt;/code&gt; and &lt;code&gt;w[n-2]&lt;/code&gt;. The variables &lt;code&gt;y0&lt;/code&gt; and &lt;code&gt;x0&lt;/code&gt; represent &lt;code&gt;y[n]&lt;/code&gt; and &lt;code&gt;x[n]&lt;/code&gt;. The coefficients of the filter are &lt;code&gt;b0&lt;/code&gt;, &lt;code&gt;b1&lt;/code&gt;, &lt;code&gt;b2&lt;/code&gt;, &lt;code&gt;a0&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt; which are calculated depending on the filter. We can see that &lt;code&gt;w1&lt;/code&gt; and &lt;code&gt;w2&lt;/code&gt; are declared as &lt;code&gt;mem&lt;/code&gt; variables since we want them to keep their value every time the function is called.&lt;/p&gt;

&lt;p&gt;Now that we have the architecture of the biquad, we can design filters. In order to design a filter we need to calculate the coefficients. Here we are gonna follow the formulae show in the Audio-EQ-Cookbook (&lt;a href=&#34;http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt&#34;&gt;http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt&lt;/a&gt;). The code for the filter is the following:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut3-2&#34;&gt;fun lowpass(x,w0,q) {
    val cos_w = cos(w0);
    val alpha = sin(w0)/(2.0*q);
    val den =  1.0 + alpha;
    val a1 =  (-2.0*cos_w)/den;
    val a2 =  (1.0 - alpha)/den;
    val b0 = ((1.0 - cos_w)/(2.0*den));
    val b1 = (1.0 - cos_w)/den;
    val b2 = ((1.0 - cos_w)/(2.0*den));
    return biquad(x,b0,b1,b2,a1,a2);
}
&lt;/div&gt;

&lt;p&gt;In the code, &lt;code&gt;x&lt;/code&gt; is the input signal &lt;code&gt;w0&lt;/code&gt; is the cut frequency (in radians) and &lt;code&gt;q&lt;/code&gt; controls the resonance. This filter is variable and we can adjust the cut frequency and the resonance. In order to achieve that we need to calculate the coefficients every time the cut or resonance changes. We can see in the above code that the implementation is not very efficient since it calculates the coefficients every sample. To improve it can use the function &lt;code&gt;change&lt;/code&gt; that we defined in the &lt;code&gt;Functions with Memory&lt;/code&gt; tutorial.&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut3-3&#34;&gt; // returns true when the input changes
fun change(current:real) : bool {
    mem previous;
    val result = current &lt;&gt; previous;
    previous = current;
    return result;
}

fun lowpass(x,w0,q) {
    mem b0,b1,b2,a1,a2;
    if(change(w0) || change(q)) {
        val cos_w = cos(w0);
        val alpha = sin(w0)/(2.0*q);
        val den =  1.0 + alpha;
        a1 =  (-2.0*cos_w)/den;
        a2 =  (1.0 - alpha)/den;
        b0 = ((1.0 - cos_w)/(2.0*den));
        b1 = (1.0 - cos_w)/den;
        b2 = ((1.0 - cos_w)/(2.0*den));
    }
    return biquad(x,b0,b1,b2,a1,a2);
}
&lt;/div&gt;

&lt;p&gt;In the example above, we have changed the declaration of the coefficients to &lt;code&gt;mem&lt;/code&gt; variables because we want to remember the previous values. By wrapping the calculation inside the &lt;code&gt;if-statement&lt;/code&gt; we recalculate the coefficients every time the values of &lt;code&gt;fc&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; change.&lt;/p&gt;

&lt;p&gt;Now that we have the filter, we can use it as part of a bigger program. For example:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut3-4&#34;&gt;
fun process(x) : real {

   ... // some other here

   val s_1 = ...; // generate a signal
   val s_2 = ...; // generate a signal

   // the first filter is controlled by control_1 and control_2
   val s_1_filtered = lowpass(s_1, control_1, control_2);

   // the second filter is controlled by control_3 and control_4
   val s_2_filtered = lowpass(s_2, control_3, control_4);

   return s_1_filtered + s_2_filtered;
}
&lt;/div&gt;

&lt;p&gt;Just for you to remember, every time you call the function &lt;code&gt;lowpass&lt;/code&gt; and independent memory space is generated. Therefore, the filter for signal &lt;code&gt;s_1&lt;/code&gt; and &lt;code&gt;s_2&lt;/code&gt; do not interfere each other.&lt;/p&gt;

&lt;p&gt;In the next tutorial we are gonna create a state-variable filter and we are gonna show how easy is to do oversampling in Vult.&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/external/ace/ace.js&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/main.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>LuaJIT as backend for Vult</title>
      <link>http://modlfo.github.io/vult/blog/lua/</link>
      <pubDate>Thu, 08 Sep 2016 22:43:03 +0300</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/lua/</guid>
      <description>&lt;p&gt;I have been keeping an eye on LuaJIT (&lt;a href=&#34;http://luajit.org&#34;&gt;http://luajit.org&lt;/a&gt;) for some time. It&amp;rsquo;s a very interesting project and I have read very good things about it. Some time ago I made a small benchmark comparing an optimized algorithm written in C++11 against a lazy coded version in OCaml and LuaJIT. In case you are curious here are the results:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Language&lt;/th&gt;
&lt;th&gt;Execution Time&lt;/th&gt;
&lt;th&gt;Lines of Code&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;td&gt;0.355 s&lt;/td&gt;
&lt;td&gt;180&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;OCaml&lt;/td&gt;
&lt;td&gt;0.54 s&lt;/td&gt;
&lt;td&gt;63&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LuaJIT&lt;/td&gt;
&lt;td&gt;0.78 s&lt;/td&gt;
&lt;td&gt;85&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Here&amp;rsquo;s a chart that plots the lines of code against the execution time.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;./images/benchmark1.svg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;I have to remark again: &lt;em&gt;The OCaml and Lua code were not written with optimization in mind&lt;/em&gt;. My intention was to see how fast they program could go without putting too much effort coding.&lt;/p&gt;

&lt;p&gt;One can see that the C++ code is much larger. On the other hand, the OCaml code is very compact. The main reason was that in OCaml I used algebraic data types which neither Lua or C++ have (&lt;a href=&#34;https://en.wikipedia.org/wiki/Algebraic_data_type&#34;&gt;https://en.wikipedia.org/wiki/Algebraic_data_type&lt;/a&gt;). Therefore, all the complex data types needed to be implemented with classes or tables in the case of Lua.&lt;/p&gt;

&lt;p&gt;Recently I implemented a prototype of code generation Vult -&amp;gt; Lua in order to check if LuaJIT could be used to create a better live coding environment. I took the JavaScript generator and with a few modifications I got Lua support.&lt;/p&gt;

&lt;p&gt;To generate Lua code you need to call Vult as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./vultc.native -luacode code.vult -o code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to check the performance I took one of the examples I have in Vult and made a test rendering 1000 s of audio. Here are the results:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Language&lt;/th&gt;
&lt;th&gt;Execution Time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;td&gt;2.77 s&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LuaJIT&lt;/td&gt;
&lt;td&gt;3.55 s&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Here&amp;rsquo;s the graphic view:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;./images/benchmark2.svg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;The results are quite promising. The code was pure Lua with exception of the arrays which are implemented using the LuaJIT FFI as &lt;code&gt;double[]&lt;/code&gt;. One important thing to notice is that the LuaJIT performs all operations in &lt;code&gt;double&lt;/code&gt; precision, while the C/C++ uses &lt;code&gt;float&lt;/code&gt;. I&amp;rsquo;m not sure if this has a big impact or not in modern processors.&lt;/p&gt;

&lt;p&gt;As follow up in this topic, I&amp;rsquo;m planning to do more testing to see if I can generate code that is faster in LuaJIT taking advantage of the FFI features. I&amp;rsquo;m gonna try as well to find a nice way of integrating LuaJIT + Vult into a VST or a PD external.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Oversampling</title>
      <link>http://modlfo.github.io/vult/tutorials/oversampling/</link>
      <pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://modlfo.github.io/vult/tutorials/oversampling/</guid>
      <description>&lt;p&gt;One common technique in Digital Signal Processing is Oversampling. Oversampling is often necessary when modeling filters that come from electric circuits or that present nonlinearities or that can become unstable for certain parameters.&lt;/p&gt;

&lt;p&gt;In order to oversample a filter we need for every sample perform &lt;code&gt;N&lt;/code&gt; steps. I a language like Vult, that hides the internal memory of a function, oversampling may seem not very obvious.&lt;/p&gt;

&lt;p&gt;In order to perform oversampling, we are gonna use a feature of Vult that allow us to name and reuse the memory created by a function.&lt;/p&gt;

&lt;p&gt;In the previous tutorial &lt;code&gt;Easy DSP with Vult&lt;/code&gt; we coded the following low pass filter.&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut4-1&#34;&gt; // returns true when the input changes
fun change(current:real) : bool {
   mem previous;
   val result = current &lt;&gt; previous;
   previous = current;
   return result;
}

fun lowpass(x,w0,q) {
    mem b0,b1,b2,a1,a2;
    if(change(w0) || change(q)) {
        val cos_w = cos(w0);
        val alpha = sin(w0)/(2.0*q);
        val den =  1.0 + alpha;
        a1 = (-2.0*cos_w)/den;
        a2 = (1.0-alpha)/den;
        b0 = (1.0-cos_w)/(2.0*den);
        b1 = (1.0-cos_w)/den;
        b2 = (1.0-cos_w)/(2.0*den);
    }
    return biquad(x,b0,b1,b2,a1,a2);
}
&lt;/div&gt;

&lt;p&gt;This filter becomes unstable when the parameter &lt;code&gt;q&lt;/code&gt; is high and the frequency &lt;code&gt;w0&lt;/code&gt; approaching &lt;code&gt;2Pi&lt;/code&gt; for that reason we cannot completely open the filter.&lt;/p&gt;

&lt;p&gt;The following code shows the low pass filter with 2x of oversampling:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut4-2&#34;&gt;fun lowpass_2x(x,w0,q) {
    val fixed_w0 = w0/2.0;
    // first call to lowpass with context &#39;inst&#39;
    _  = inst:lowpass(x,fixed_w0,q);
    // second call to lowpass with the same context &#39;inst&#39;
    val y = inst:lowpass(x,fixed_w0,q);
    return y;
}
&lt;/div&gt;

&lt;p&gt;First we need to fix the frequency &lt;code&gt;w0&lt;/code&gt;. From Audio-EQ-Cookbook we have the formula &lt;code&gt;w0 = 2*pi*f0/Fs&lt;/code&gt;, since we have double the sampling rate, it is enough to divide the original &lt;code&gt;w0&lt;/code&gt; by two. Then we use the feature of Vult that allow us to name the context of a function and reuse them. By preceding a call of a function with memory with an identifier and colon we can assign a name to the context e.g. &lt;code&gt;inst:lowpass(...)&lt;/code&gt;. If we want to call again the function and not creating a new context we have to use the same name.&lt;/p&gt;

&lt;p&gt;if we want to create modify the filter above and make it stereo we can do it as follows:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut4-3&#34;&gt;fun lowpass_2x(l,r,w0,q) {
    val fixed_w0 = w0/2.0;
    // process the left side
    _         = left:lowpass(l,fixed_w0,q);
    val l_out = left:lowpass(l,fixed_w0,q);
    // process the right side
    _         = right:lowpass(l,fixed_w0,q);
    val r_out = right:lowpass(r,fixed_w0,q);
    return l_out,r_out;
}
&lt;/div&gt;

&lt;p&gt;Notice that we have named the contexts of the functions &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;. In a similar way, we can easily make this filter with 4x of oversampling.&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut4-4&#34;&gt;fun lowpass_4x(l,r,w0,q) {
    val fixed_w0 = w0/4.0;
    // process the left side
    _         = left:lowpass(l,fixed_w0,q);
    _         = left:lowpass(l,fixed_w0,q);
    _         = left:lowpass(l,fixed_w0,q);
    val l_out = left:lowpass(l,fixed_w0,q);
    // process the right side
    _         = right:lowpass(l,fixed_w0,q);
    _         = right:lowpass(l,fixed_w0,q);
    _         = right:lowpass(l,fixed_w0,q);
    val r_out = right:lowpass(r,fixed_w0,q);
    return l_out,r_out;
}
&lt;/div&gt;

&lt;p&gt;In the next tutorial we are gonna learn how to export code to C/C++.&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/external/ace/ace.js&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/main.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Generating Pure Data and Teensy Audio templates</title>
      <link>http://modlfo.github.io/vult/blog/pd-teensy/</link>
      <pubDate>Wed, 13 Jul 2016 20:10:57 +0200</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/pd-teensy/</guid>
      <description>&lt;p&gt;As part of the Vult project I have developed a new standalone library: Pla (&lt;a href=&#34;https://modlfo.github.io/pla/&#34;&gt;https://modlfo.github.io/pla/&lt;/a&gt;). Pla is a templating library that is used in Vult to generate code in a simpler way. Thanks to this library I have developed two templates to simplify using Vult:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/modlfo/pd-vult-example&#34;&gt;Pure Data externals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/modlfo/pd-vult-example&#34;&gt;Teensy Audio Library objects&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The template for Pure Data is more stable. It supports both, floating-point and fixed-point arithmetics. In addition, the number of inputs and outputs of the &amp;lsquo;external&amp;rsquo; matches the inputs and outputs of the &lt;code&gt;process&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;You can find an example of using it in this repository: &lt;a href=&#34;https://github.com/modlfo/pd-vult-example&#34;&gt;https://github.com/modlfo/pd-vult-example&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Exporting of objects for the Teensy Audio Library is only available in fixed-point and (currently) only supports synthesis objects (I have plans to make it as flexible as the PD template).&lt;/p&gt;

&lt;p&gt;Here you can find an example: &lt;a href=&#34;https://github.com/modlfo/teensy-vult-example&#34;&gt;https://github.com/modlfo/teensy-vult-example&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>New site for Vult</title>
      <link>http://modlfo.github.io/vult/blog/new-site/</link>
      <pubDate>Tue, 12 Jul 2016 20:21:43 +0200</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/new-site/</guid>
      <description>&lt;p&gt;I have been working on giving a refresh of the Vult site. The result is what you see now. After trying a few alternatives I settle to use Hugo (&lt;a href=&#34;https://gohugo.io&#34;&gt;https://gohugo.io&lt;/a&gt;). The reason I used Hugo was because I could make it do exactly what I wanted with the help of the documentation.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m very proud that I did the theme of the site from the ground up (that&amp;rsquo;s why is so minimalistic). I also added comments section using Google+, and I hope it works as expected.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Comment summary</title>
      <link>http://modlfo.github.io/vult/comments/</link>
      <pubDate>Tue, 12 Jul 2016 17:59:24 +0200</pubDate>
      
      <guid>http://modlfo.github.io/vult/comments/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Vult Blog</title>
      <link>http://modlfo.github.io/vult/blog/</link>
      <pubDate>Tue, 12 Jul 2016 17:59:24 +0200</pubDate>
      
      <guid>http://modlfo.github.io/vult/blog/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Vult Overview</title>
      <link>http://modlfo.github.io/vult/overview/</link>
      <pubDate>Tue, 12 Jul 2016 17:59:24 +0200</pubDate>
      
      <guid>http://modlfo.github.io/vult/overview/</guid>
      <description>

&lt;p&gt;Vult is a simple and powerful language to program high-performance algorithms that may run in small microprocessors or microcontrollers. Vult is specially useful when programming Digital Signal Processing (DSP) algorithms like audio effects or synthesizers.&lt;/p&gt;

&lt;h2 id=&#34;code-generation&#34;&gt;Code Generation&lt;/h2&gt;

&lt;p&gt;The Vult compiler is a transcompiler which takes Vult code and produces C/C++ or JavaScript code. The C/C++ code that can be compiled in any platform with a C/C++ compiler, for example: Arduino or Teensy boards. The Javascript that can be run directly in the browser.&lt;/p&gt;

&lt;p&gt;In addition Vult provides templates that generate code that can be directly compiled into a Pure Data external or an object compatible with the Teensy Audio Library.&lt;/p&gt;

&lt;p&gt;Code written in Vult has freedom.&lt;/p&gt;

&lt;h2 id=&#34;language-features&#34;&gt;Language Features&lt;/h2&gt;

&lt;p&gt;Some of the key feature of Vult are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Fixed-Point type&lt;/strong&gt;: The same code can be generated using float or fixed-point arithmetic. This makes it possible to run efficiently in small processors.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Functions with context&lt;/strong&gt;: Functions in Vult can have local memory and each call automatically creates a new environment. Contexts can be shared among functions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Type inference and type checking&lt;/strong&gt;: the type system makes your code safer and will catch many of the errors made when writing code.
These key features enable you to write clear and simple code without sacrificing performance.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;status&#34;&gt;Status&lt;/h2&gt;

&lt;p&gt;Vult is on continuous development, suggestions for new features are welcome.&lt;/p&gt;

&lt;h2 id=&#34;roadmap&#34;&gt;Roadmap&lt;/h2&gt;

&lt;p&gt;You can see what we are working on and what&amp;rsquo;s planned for Vult in the &lt;a href=&#34;https://waffle.io/modlfo/vult&#34;&gt;https://waffle.io/modlfo/vult&lt;/a&gt; board.&lt;/p&gt;

&lt;p&gt;If you want to receive notifications for future development of this project you can join to the google group Vult Group.&lt;/p&gt;

&lt;h2 id=&#34;credits&#34;&gt;Credits&lt;/h2&gt;

&lt;p&gt;Logo design by: John Klimt &lt;a href=&#34;https://www.facebook.com/JohnKlimt&#34;&gt;https://www.facebook.com/JohnKlimt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Vult is maintained by &lt;strong&gt;modlfö&lt;/strong&gt; (Leonardo Laguna Ruiz) with the help of Carl Jönsson and Johan Rhodin.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vult Tutorials</title>
      <link>http://modlfo.github.io/vult/tutorials/</link>
      <pubDate>Tue, 12 Jul 2016 17:59:24 +0200</pubDate>
      
      <guid>http://modlfo.github.io/vult/tutorials/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>